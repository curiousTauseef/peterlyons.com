#!/bin/bash
##### helper functions #####
autoinstall_wallah() {
  [[ -f wallah/bin/install_node ]] && return
  git submodule update --init --depth 1
}

usage() {
  printf "Usage: $(basename $0) [" 1>&2
  while read line; do
    if echo "${line}" | egrep '^task::' >/dev/null; then
      task=$(echo "${line}" \
        | cut -d : -f 3 \
        | cut -d '(' -f 1
      )
      if [[ -z "${first}" ]]; then
        first="false"
      else
        printf "|"
      fi
      printf "${task}"
    fi
  done < <(cat "$0")
  printf "] [subcommand args...]\n" 1>&2
  cat <<-EOF

	Purpose of $(basename $0) script
	--------------------

	* entrypoint script for common commands
	* Automatically installs development prerequisites
	* Ensures the correct PATH environment variable
	* commands are grouped by purpose/lifecycle and described in more detail below


	Development Commands
	--------------------

	* express: start the express server (aliased as "start"):
	* test: run all the tests (mocha and karma)
	* test_debug: run mocha tests with immediate breakpoint for debugging
	* karma: start karma process to continuously watch and run tests
	* validate: Run W3C HTML5 validator against the site HTML

	Deployment Commands
	-------------------

	* clean: delete the build directory
	* build: build a distribution archive for deployment
    * Usage: $(basename $0) build <HEAD|WORK|TAG>
    * $(basename $0) build HEAD will use the last commit on the current branch
    * $(basename $0) build WORK will use uncommited local changes
    * $(basename $0) build TAG will use the code in the given git tag
	* release_candidate: begin git work to prepare for a build/test/release
	  * Usage: $(basename $0) release_candidate <patch|minor|major>
	* release: merge develop to master, tag, and push to origin
	  * Usage: $(basename $0) release
	* errors: regenerate the static error HTML pages
	* deploy: deploy code to a target system via ansible
	  * Usage: $(basename $0) deploy <dist-file> <inventory-file>
	  * will deploy the full stack to the server(s) listed in the ansible yaml inventory file argument
	  * distribution archive files get built in the "build" directory
	  * inventory files live in the deploy/hosts directory
	* ansible: just a convenience wrapper around ./python/bin/ansible
	  * used for running ad hoc ansible commands
	  * installs ansible if needed
	  * arguments are passed through to ./python/bin/ansible
	* ansible-playbook: just a convenience wrapper around ./python/bin/ansible-playbook
	  * used for running ad hoc ansible-playbook commands
	  * installs ansible if needed
	  * arguments are passed through to ./python/bin/ansible-playbook
	* vagrant: just a convenience wrapper around vagrant with the correct environment
EOF
  exit 1
}

##### development task functions #####
task::express() {
  autoinstall_wallah
  ./wallah/bin/install_node
  node-dev --debug=9001 app/server.js
}

task::start() {
  task::express "$@"
}

task::test() {
  autoinstall_wallah
  ./wallah/bin/install_node
  NODE_ENV=test mocha "$@"
  #@bug these are busted
  #karma run karma/karma.conf.js
}

task::test_debug() {
  autoinstall_wallah
  ./wallah/bin/install_node
  NODE_ENV=test mocha --debug-brk=9004 "$@"
}

task::karma() {
  exec karma start karma/karma.conf.js
}

task::validate() {
  NODE_ENV=test mocha ./test/application/validation.js --validate
}

task::release_candidate() {
  echo "Creating a new release candidate"
  git checkout develop
  git pull origin develop
  ./node_modules/.bin/bumpy "${1-patch}"
  git diff package.json
  git add package.json
  local tag="v$(./wallah/bin/get_json_value package.json version)"
  git commit -m "bump version for ${tag} release"
  git tag "${tag}"
  cat <<-EOF
	Ready
	Next steps are:
		go build
		deploy to stage
		test on stage
		go release
		deploy to prod
EOF

}

task::release() {
  git checkout develop
  git pull origin develop
  task::test
  echo "Will merge develop to master and push to origin"
  echo "CTRL-C now to abort. ENTER to proceed."
  read DONTCARE
  git checkout master
  git merge develop
  git push origin master --tags
  git checkout develop #Not good form to leave master checked out
  echo "Done. Miller Time."
}

##### deployment task functions #####
task::clean() {
  rm -rf ./build ./dist
}

task::build() {
  set -e
  #need the build system python here
  export PATH=/usr/bin:$PATH
  local git_ref="${1-HEAD}"
  local build_dir="build"
  local prefix="peterlyons.com-${git_ref}-$(date +%Y%m%d%H%M)"
  printf "prereqs..."
  autoinstall_wallah
  ./wallah/bin/check_prerequisites git tar
  mkdir -p "${build_dir}/${prefix}/node"

  printf "git archive..."
  #note we need to use "-C" with tar and not "--directory" due to bsdtar on osx
  if [[ "${git_ref}" == "WORK" ]]; then
    git ls-files \
      | tar -T - --create --file - \
      | tar -C "${build_dir}/${prefix}" --extract --file -
  else
    git archive --format=tar --prefix="${prefix}/" "${git_ref}" | \
      #extract that archive into a temporary build directory
      tar -C "${build_dir}" --extract
  fi
  local node_version=$(./wallah/bin/get_json_value \
    "${build_dir}/${prefix}/package.json" "engines.node")
  #install node
  printf "node..."
  #Make sure we have npm-pkgr installed locally
  npm install npm-pkgr
  tar -C "${build_dir}/${prefix}/node" --strip-components=1 --extract --gzip \
    --file "node-v${node_version}-linux-x86.tar.gz"
  (
  	cd "${build_dir}/${prefix}"
	  #remove development-only files
    rm -rf wallah doc deploy test karma Vagrantfile \
      .gitignore .agignore .gitmodules
  	printf "npm packages..."
	  ../../node_modules/.bin/npm-pkgr --strategy=copy --production \
	    --silent --parseable &> "../npm.log"
    cd node_modules
    ln -nsf ../app
	)
	printf "vagrant rebuild..."
  ./bin/go vagrant ssh build -c \
    "'cd /vagrant/${build_dir}/${prefix} && ./node/bin/npm rebuild --silent --parseable &>> ../npm.log'"
  echo "archive"
  local dist_path="${build_dir}/${prefix}.tar.gz"
  tar -C "${build_dir}" --create --gzip --file "${dist_path}" "${prefix}"
  ls -lh "${dist_path}"
  echo "To deploy to stage, run:"
  printf "\t./bin/go deploy ${dist_path} deploy/hosts/vagrant_stage.yml\n"
}

task::errors() {
  autoinstall_wallah
  ./wallah/bin/check_prerequisites curl
  local devurl="http://localhost:9000"
  local static="../static"
  echo "Generating HTML for static error pages from ${devurl}..."
  for uri in error404 error500; do
    local url="${devurl}/${uri}"
    printf "${uri}, "
    local exit_code=0
    curl --silent "${url}" --output \
        "${static}/${uri}.html" || exit_code=$?
    if [ ${exit_code} -ne 0 ]; then
        echo "FAILED to retrieve ${url}"
        exit ${exit_code}
    fi
  done
}

task::deploy() {
  autoinstall_wallah
  ./wallah/bin/install_pip_package ansible
  local dist_path="$1"
  local dist_name=$(basename "${dist_path}")
  dist_name=$(echo "${dist_name}" | sed 's/\.tar\...//')
  local inventory="$2"
  ANSIBLE_HOST_KEY_CHECKING=False exec ansible-playbook \
    -i "${inventory}" \
    --ask-sudo-pass \
    --extra-vars "'dist=${dist_path}'" \
    --extra-vars "'dist_name=${dist_name}'" \
    ./deploy/playbook_express.yml
}

task::vagrant() {
  autoinstall_wallah
  ./wallah/bin/install_pip_package ansible
  exec vagrant "$@"
}

task::ansible-playbook() {
  autoinstall_wallah
  ./wallah/bin/install_pip_package ansible
  ANSIBLE_HOST_KEY_CHECKING=False exec ansible-playbook "$@"
}

##### main code #####
main() {
  cd "$(dirname $0)/.."
  PATH="${PWD}/python/bin"
  PATH="${PATH}:${PWD}/node/bin"
  PATH="${PATH}:${PWD}/node_modules/.bin"
  #Need the basics like dirname et al
  PATH="${PATH}:/usr/bin:/bin"
  export PATH
  task_name="$1"
  if type "task::${task_name}" &>/dev/null; then
    shift
    eval "task::${task_name}" "$@"
  else
    usage "$@"
  fi
}

main "$@"
